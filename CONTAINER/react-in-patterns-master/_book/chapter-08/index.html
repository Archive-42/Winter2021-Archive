
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Flux Â· React in patterns</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="Krasimir Tsonev">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="./" />
    
    
    <link rel="prev" href="../chapter-07/" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../chapter-01/">
            
                <a href="../chapter-01/">
            
                    
                    In brief
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Foundation</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../chapter-02/">
            
                <a href="../chapter-02/">
            
                    
                    Communication
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.1.1" data-path="../chapter-02/">
            
                <a href="../chapter-02/#input">
            
                    
                    Input
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.2" data-path="../chapter-02/">
            
                <a href="../chapter-02/#output">
            
                    
                    Output
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="../chapter-03/">
            
                <a href="../chapter-03/">
            
                    
                    Event handlers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="../chapter-04/">
            
                <a href="../chapter-04/">
            
                    
                    Composition
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.3.1" data-path="../chapter-04/">
            
                <a href="../chapter-04/#using-reacts-children-api">
            
                    
                    Using React's children API
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.2" data-path="../chapter-04/">
            
                <a href="../chapter-04/#passing-a-child-as-a-prop">
            
                    
                    Passing a child as a prop
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.3" data-path="../chapter-04/">
            
                <a href="../chapter-04/#higher-order-component">
            
                    
                    Higher-order component
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.4" data-path="../chapter-04/">
            
                <a href="../chapter-04/#function-as-a-children-render-prop">
            
                    
                    Function as a children, render prop
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="2.4" data-path="../chapter-05/">
            
                <a href="../chapter-05/">
            
                    
                    Controlled and uncontrolled inputs
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.5" data-path="../chapter-06/">
            
                <a href="../chapter-06/">
            
                    
                    Presentational and container components
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Data flow</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../chapter-07/">
            
                <a href="../chapter-07/">
            
                    
                    One direction data flow
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="3.2" data-path="./">
            
                <a href="./">
            
                    
                    Flux
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.2.1" data-path="./">
            
                <a href="./#flux-architecture-and-its-main-characteristics">
            
                    
                    Flux architecture and its main characteristics
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2.2" data-path="./">
            
                <a href="./#implementing-a-flux-architecture">
            
                    
                    Implementing a Flux architecture
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="../chapter-09/">
            
                <a href="../chapter-09/">
            
                    
                    Redux
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.3.1" data-path="../chapter-09/">
            
                <a href="../chapter-09/#redux-architecture-and-its-main-characteristics">
            
                    
                    Redux architecture and its main characteristics
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.3.2" data-path="../chapter-09/">
            
                <a href="../chapter-09/#simple-counter-app-using-redux">
            
                    
                    Simple counter app using Redux
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="header">Good to know</li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="../chapter-10/">
            
                <a href="../chapter-10/">
            
                    
                    Dependency injection
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.1" data-path="../chapter-10/">
            
                <a href="../chapter-10/#using-reacts-context-prior-v-163">
            
                    
                    Using React's context (prior v. 16.3)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.2" data-path="../chapter-10/">
            
                <a href="../chapter-10/#using-reacts-context-v-163-and-above">
            
                    
                    Using React's context (v. 16.3 and above)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3" data-path="../chapter-10/">
            
                <a href="../chapter-10/#using-the-module-system">
            
                    
                    Using the module system
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="4.2" data-path="../chapter-11/">
            
                <a href="../chapter-11/">
            
                    
                    Styling
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.2.1" data-path="../chapter-11/">
            
                <a href="../chapter-11/#the-good-old-css-class">
            
                    
                    The good old CSS class
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2.2" data-path="../chapter-11/">
            
                <a href="../chapter-11/#inline-styling">
            
                    
                    Inline styling
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2.3" data-path="../chapter-11/">
            
                <a href="../chapter-11/#css-modules">
            
                    
                    CSS modules
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2.4" data-path="../chapter-11/">
            
                <a href="../chapter-11/#styled-components">
            
                    
                    Styled-components
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="4.3" data-path="../chapter-12/">
            
                <a href="../chapter-12/">
            
                    
                    Integration of third-party libraries
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.4" data-path="../chapter-13/">
            
                <a href="../chapter-13/">
            
                    
                    React and separation of concerns
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Summary</li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="../chapter-14/">
            
                <a href="../chapter-14/">
            
                    
                    Summary
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Flux</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="flux">Flux</h1>
<p>I&apos;m obsessed by making my code simpler. I didn&apos;t say <em>smaller</em> because having less code doesn&apos;t mean that is simple and easy to work with. I believe that big part of the problems in the software industry come from the unnecessary complexity. Complexity which is a result of our own abstractions. You know, we (the programmers) like to abstract. We like placing things in black boxes and hope that these boxes work together.</p>
<p><a href="http://facebook.github.io/flux/" target="_blank">Flux</a> is an architectural design pattern for building user interfaces. It was introduced by Facebook at their <a href="https://youtu.be/nYkdrAPrdcw?t=568" target="_blank">F8</a> conference. Since then, lots of companies adopted the idea and it seems like a good pattern for building front-end apps. Flux is very often used with <a href="http://facebook.github.io/react/" target="_blank">React</a>. Another library released by Facebook. I myself use React+Flux/Redux in my <a href="http://antidote.me/" target="_blank">daily job</a> and I could say that it is simple and really flexible. The pattern helps creating apps faster and at the same time keeps the code well organized.</p>
<h2 id="flux-architecture-and-its-main-characteristics">Flux architecture and its main characteristics</h2>
<p><img src="fluxiny_basic_flux_architecture.jpg" alt="Basic flux architecture"></p>
<p>The main actor in this pattern is the <em>dispatcher</em>. It acts as a hub for all the events in the system. Its job is to receive notifications that we call <em>actions</em> and pass them to all the <em>stores</em>. The store decides if it is interested or not and reacts by changing its internal state/data. That change is triggering re-rendering of the <em>views</em> which are (in our case) React components. If we have to compare Flux to the well known MVC we may say that the store is similar to the model. It keeps the data and its mutations.</p>
<p>The actions are coming to the dispatcher either from the views or from other parts of the system, like services. For example a module that performs a HTTP request. When it receives the result it may fire an action saying that the request was successful.</p>
<h2 id="implementing-a-flux-architecture">Implementing a Flux architecture</h2>
<p>As every other popular concept Flux also has some <a href="https://medium.com/social-tables-tech/we-compared-13-top-flux-implementations-you-won-t-believe-who-came-out-on-top-1063db32fe73" target="_blank">variations</a>. Very often to understand something we have to implement it. In the next few sections we will create a library that provides helpers for building the Flux pattern.</p>
<h3 id="the-dispatcher">The dispatcher</h3>
<p>In most of the cases we need a single dispatcher. Because it acts as a glue for the rest of the parts it makes sense that we have only one. The dispatcher needs to know about two things - actions and stores. The actions are simply forwarded to the stores so we don&apos;t necessary have to keep them. The stores however should be tracked inside the dispatcher so we can loop through them:</p>
<p><img src="fluxiny_the_dispatcher.jpg" alt="the dispatcher"></p>
<p>That&apos;s what I started with:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> Dispatcher = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    _stores: [],
    register: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">store</span>) </span>{  
      <span class="hljs-keyword">this</span>._stores.push({ store: store });
    },
    dispatch: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._stores.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">this</span>._stores.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">entry</span>) </span>{
          entry.store.update(action);
        });
      }
    }
  }
};
</code></pre>
<p>The first thing that we notice is that we <em>expect</em> to see an <code>update</code> method in the passed stores. It will be nice to throw an error if such method is not there:</p>
<pre><code class="lang-js">register: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">store</span>) </span>{
  <span class="hljs-keyword">if</span> (!store || !store.update) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&apos;You should provide a store that has an `update` method.&apos;</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>._stores.push({ store: store });
  }
}
</code></pre>
<p><br></p>
<h3 id="bounding-the-views-and-the-stores">Bounding the views and the stores</h3>
<p>The next logical step is to connect our views to the stores so we re-render when the state in the stores is changed.</p>
<p><img src="fluxiny_store_change_view.jpg" alt="Bounding the views and the stores"></p>
<h4 id="using-a-helper">Using a helper</h4>
<p>Some of the flux implementations available out there provide a helper function that does the job. For example:</p>
<pre><code class="lang-js">Framework.attachToStore(view, store);
</code></pre>
<p>However, I don&apos;t quite like this approach. To make <code>attachToStore</code> works we expect to see a specific API in the view and in the store. We kind of strictly define new public methods. Or in other words we say &quot;Your views and store should have such APIs so we are able to wire them together&quot;. If we go down this road then we will probably define our own base classes which could be extended so we don&apos;t bother the developer with Flux details. Then we say &quot;All your classes should extend our classes&quot;. This doesn&apos;t sound good either because the developer may decide to switch to another Flux provider and has to amend everything.</p>
<p><br><br></p>
<h4 id="with-a-mixin">With a mixin</h4>
<p>What if we use React&apos;s <a href="https://reactjs.org/docs/react-without-es6.html#mixins" target="_blank">mixins</a>.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> View = React.createClass({
  mixins: [Framework.attachToStore(store)]
  ...
});
</code></pre>
<p>That&apos;s a &quot;nice&quot; way to define behavior of existing React component. So, in theory we may create a mixin that does the bounding for us. To be honest, I don&apos;t think that this is a good idea. And <a href="https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750" target="_blank">it looks</a> like it&apos;s not only me. My reason of not liking mixins is that they modify the components in a non-predictable way. I have no idea what is going on behind the scenes. So I&apos;m crossing this option.</p>
<h4 id="using-a-context">Using a context</h4>
<p>Another technique that may answer the question is React&apos;s <a href="https://facebook.github.io/react/docs/context.html" target="_blank">context</a>. It is a way to pass props to child components without the need to specify them in every level of the tree. Facebook suggests context in the cases where we have data that has to reach deeply nested components.</p>
<blockquote>
<p>Occasionally, you want to pass data through the component tree without having to pass the props down manually at every level. React&apos;s &quot;context&quot; feature lets you do this.</p>
</blockquote>
<p>I see similarity with the mixins here. The context is defined somewhere at the top and magically serves props for all the children below. It&apos;s not immediately clear where the data comes from.</p>
<p><br><br><br></p>
<h4 id="higher-order-components-concept">Higher-Order components concept</h4>
<p>Higher-Order components pattern is <a href="https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775" target="_blank">introduced</a> by Sebastian Markb&#xE5;ge and it&apos;s about creating a wrapper component that returns ours. While doing it, it has the opportunity to send properties or apply additional logic. For example:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attachToStore</span>(<span class="hljs-params">Component, store, consumer</span>) </span>{
  <span class="hljs-keyword">const</span> Wrapper = React.createClass({
    getInitialState() {
      <span class="hljs-keyword">return</span> consumer(<span class="hljs-keyword">this</span>.props, store);
    },
    componentDidMount() {
      store.onChangeEvent(<span class="hljs-keyword">this</span>._handleStoreChange);
    },
    componentWillUnmount() {
      store.offChangeEvent(<span class="hljs-keyword">this</span>._handleStoreChange);
    },
    _handleStoreChange() {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isMounted()) {
        <span class="hljs-keyword">this</span>.setState(consumer(<span class="hljs-keyword">this</span>.props, store));
      }
    },
    render() {
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> {<span class="hljs-attr">...this.props</span>} {<span class="hljs-attr">...this.state</span>} /&gt;</span>;
    }
  });
  return Wrapper;
};
</span></code></pre>
<p><code>Component</code> is the view that we want attached to the <code>store</code>. The <code>consumer</code> function says what part of the store&apos;s state should be fetched and sent to the view. A simple usage of the above function could be:</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
}

ProfilePage = connectToStores(MyView, store, (props, store) =&gt; ({
  data: store.get(<span class="hljs-string">&apos;key&apos;</span>)
}));
</code></pre>
<p>That is an interesting pattern because it shifts the responsibilities. It is the view fetching data from the store and not the store pushing something to the view. This of course has it&apos;s own pros and cons. It is nice because it makes the store dummy. A store that only mutates the data and says &quot;Hey, my state is changed&quot;. It is not responsible for sending anything to anyone. The downside of this approach is maybe the fact that we have one more component (the wrapper) involved. We also need the three things - view, store and consumer to be in one place so we can establish the connection.</p>
<h4 id="my-choice">My choice</h4>
<p>The last option above, higher-order components, is really close to what I&apos;m searching for. I like the fact that the view decides what it needs. That <em>knowledge</em> anyway exists in the component so it makes sense to keep it there. That&apos;s also why the functions that generate higher-order components are usually kept in the same file as the view. What if we can use similar approach but not passing the store at all. Or in other words, a function that accepts only the consumer. And that function is called every time when there is a change in the store.</p>
<p>So far our implementation interacts with the store only in the <code>register</code> method.</p>
<pre><code class="lang-js">register: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">store</span>) </span>{
  <span class="hljs-keyword">if</span> (!store || !store.update) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&apos;You should provide a store that has an `update` method.&apos;</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>._stores.push({ store: store });
  }
}
</code></pre>
<p>By using <code>register</code> we keep a reference to the store inside the dispatcher. However, <code>register</code> returns nothing. And instead of nothing it may return a <strong>subscriber</strong> that will accept our consumer functions.</p>
<p><img src="fluxiny_store_view.jpg" alt="Fluxiny - connect store and view"></p>
<p>I decided to send the whole store to the consumer function and not the data that the store keeps. Like in the higher-order components pattern the view should say what it needs by using store&apos;s getters. This makes the store really simple and there is no trace of presentational logic.</p>
<p>Here is how the register method looks like after the changes:</p>
<pre><code class="lang-js">register: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">store</span>) </span>{
  <span class="hljs-keyword">if</span> (!store || !store.update) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
      <span class="hljs-string">&apos;You should provide a store that has an `update` method.&apos;</span>
    );
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> consumers = [];
    <span class="hljs-keyword">var</span> subscribe = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">consumer</span>) </span>{
      consumers.push(consumer);
    };

    <span class="hljs-keyword">this</span>._stores.push({ store: store });
    <span class="hljs-keyword">return</span> subscribe;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>
<p>The last bit in the story is how the store says that its internal state is changed. It&apos;s nice that we collect the consumer functions but right now there is no code that executes them.</p>
<p>According to the basic principles of the flux architecture the stores change their state in response of actions. In the <code>update</code> method we send the <code>action</code> but we could also send a function <code>change</code>. Calling that function should trigger the consumers:</p>
<pre><code class="lang-js">register: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">store</span>) </span>{
  <span class="hljs-keyword">if</span> (!store || !store.update) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
      <span class="hljs-string">&apos;You should provide a store that has an `update` method.&apos;</span>
    );
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> consumers = [];
    <span class="hljs-keyword">var</span> change = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      consumers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">consumer</span>) </span>{
        consumer(store);
      });
    };
    <span class="hljs-keyword">var</span> subscribe = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">consumer</span>) </span>{
      consumers.push(consumer);
    };

    <span class="hljs-keyword">this</span>._stores.push({ store: store, change: change });
    <span class="hljs-keyword">return</span> subscribe;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
},
dispatch: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._stores.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">this</span>._stores.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">entry</span>) </span>{
      entry.store.update(action, entry.change);
    });
  }
}
</code></pre>
<p><em>Notice how we push <code>change</code> together with <code>store</code> inside the <code>_stores</code> array. Later in the <code>dispatch</code> method we call <code>update</code> by passing the <code>action</code> and the <code>change</code> function.</em></p>
<p>A common use case is to render the view with the initial state of the store. In the context of our implementation this means firing all the consumers at least once when they land in the library. This could be easily done in the <code>subscribe</code> method:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> subscribe = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">consumer, noInit</span>) </span>{
  consumers.push(consumer);
  !noInit ? consumer(store) : <span class="hljs-literal">null</span>;
};
</code></pre>
<p>Of course sometimes this is not needed so we added a flag which is by default falsy. Here is the final version of our dispatcher:</p>
<p><span class="new-page"></span></p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> Dispatcher = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    _stores: [],
    register: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">store</span>) </span>{
      <span class="hljs-keyword">if</span> (!store || !store.update) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
          <span class="hljs-string">&apos;You should provide a store that has an `update` method&apos;</span>
        );
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> consumers = [];
        <span class="hljs-keyword">var</span> change = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          consumers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">consumer</span>) </span>{
            consumer(store);
          });
        };
        <span class="hljs-keyword">var</span> subscribe = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">consumer, noInit</span>) </span>{
          consumers.push(consumer);
          !noInit ? consumer(store) : <span class="hljs-literal">null</span>;
        };

        <span class="hljs-keyword">this</span>._stores.push({ store: store, change: change });
        <span class="hljs-keyword">return</span> subscribe;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    },
    dispatch: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._stores.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">this</span>._stores.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">entry</span>) </span>{
          entry.store.update(action, entry.change);
        });
      }
    }
  }
};
</code></pre>
<p><span class="new-page"></span></p>
<h2 id="the-actions">The actions</h2>
<p>You probably noticed that we didn&apos;t talk about the actions. What are they? The convention is that they should be simple objects having two properties - <code>type</code> and <code>payload</code>:</p>
<pre><code class="lang-js">{
  type: <span class="hljs-string">&apos;USER_LOGIN_REQUEST&apos;</span>,
  payload: {
    username: <span class="hljs-string">&apos;...&apos;</span>,
    password: <span class="hljs-string">&apos;...&apos;</span>
  }
}
</code></pre>
<p>The <code>type</code> says what exactly the action is and the <code>payload</code> contains the information associated with the event. And in some cases we may leave the <code>payload</code> empty.</p>
<p>It&apos;s interesting that the <code>type</code> is well known in the beginning. We know what type of actions should be floating in our app, who is dispatching them and which of the stores are interested. Thus, we can apply <a href="http://krasimirtsonev.com/blog/article/a-story-about-currying-bind" target="_blank">partial application</a> and avoid passing the action object here and there. For example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> createAction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">if</span> (!type) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&apos;Please, provide action\&apos;s type.&apos;</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">payload</span>) </span>{
      <span class="hljs-keyword">return</span> dispatcher.dispatch({
        type: type,
        payload: payload
      });
    }
  }
}
</code></pre>
<p><code>createAction</code> leads to the following benefits:</p>
<ul>
<li>We no more need to remember the exact type of the action. We now have a function which we call passing only the payload.</li>
<li>We no more need an access to the dispatcher which is a huge benefit. Otherwise, think about how we have to pass it to every single place where we need to dispatch an action.</li>
<li>In the end we don&apos;t have to deal with objects but with functions which is much nicer. The objects are <em>static</em> while the functions describe a <em>process</em>.</li>
</ul>
<p><img src="fluxiny_action_creator.jpg" alt="Fluxiny actions creators"></p>
<p>This approach for creating actions is actually really popular and functions like the one above are usually called <em>action creators</em>.</p>
<h2 id="the-final-code">The final code</h2>
<p>In the section above we successfully hide the dispatcher while submitting actions. We may do it again for the store&apos;s registration:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> createSubscriber = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">store</span>) </span>{
  <span class="hljs-keyword">return</span> dispatcher.register(store);
}
</code></pre>
<p>And instead of exporting the dispatcher we may export only these two functions <code>createAction</code> and <code>createSubscriber</code>. Here is how the final code looks like:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> Dispatcher = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    _stores: [],
    register: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">store</span>) </span>{
      <span class="hljs-keyword">if</span> (!store || !store.update) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
          <span class="hljs-string">&apos;You should provide a store that has an `update` method&apos;</span>
        );
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> consumers = [];
        <span class="hljs-keyword">var</span> change = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          consumers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">consumer</span>) </span>{
            consumer(store);
          });
        };
        <span class="hljs-keyword">var</span> subscribe = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">consumer, noInit</span>) </span>{
          consumers.push(consumer);
          !noInit ? consumer(store) : <span class="hljs-literal">null</span>;
        };

        <span class="hljs-keyword">this</span>._stores.push({ store: store, change: change });
        <span class="hljs-keyword">return</span> subscribe;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    },
    dispatch: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._stores.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">this</span>._stores.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">entry</span>) </span>{
          entry.store.update(action, entry.change);
        });
      }
    }
  }
};

<span class="hljs-built_in">module</span>.exports = {
  create: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> dispatcher = Dispatcher();

    <span class="hljs-keyword">return</span> {
      createAction: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>{
        <span class="hljs-keyword">if</span> (!type) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&apos;Please, provide action\&apos;s type.&apos;</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">payload</span>) </span>{
            <span class="hljs-keyword">return</span> dispatcher.dispatch({
              type: type,
              payload: payload
            });
          }
        }
      },
      createSubscriber: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">store</span>) </span>{
        <span class="hljs-keyword">return</span> dispatcher.register(store);
      }
    }
  }
};
</code></pre>
<p>If we add the support of AMD, CommonJS and global usage we end up with 66 lines of code, 1.7KB plain or 795 bytes after minification JavaScript.</p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>We have a module that provides two helpers for building a Flux project. Let&apos;s write a simple counter app that doesn&apos;t involve React so we see the pattern in action.</p>
<p><span class="new-page"></span></p>
<h3 id="the-markup">The markup</h3>
<p>We&apos;ll need some UI to interact with it so:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;counter&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>increase<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>decrease<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>The <code>span</code> will be used for displaying the current value of our counter. The buttons will change that value.</p>
<h3 id="the-view">The view</h3>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> View = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">subscribeToStore, increase, decrease</span>) </span>{
  <span class="hljs-keyword">var</span> value = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&apos;#counter&apos;</span>);
  <span class="hljs-keyword">var</span> display = el.querySelector(<span class="hljs-string">&apos;span&apos;</span>);
  <span class="hljs-keyword">var</span> [ increaseBtn, decreaseBtn ] =
    <span class="hljs-built_in">Array</span>.from(el.querySelectorAll(<span class="hljs-string">&apos;button&apos;</span>));

  <span class="hljs-keyword">var</span> render = () =&gt; display.innerHTML = value;
  <span class="hljs-keyword">var</span> updateState = (store) =&gt; value = store.getValue();

  subscribeToStore([updateState, render]);

  increaseBtn.addEventListener(<span class="hljs-string">&apos;click&apos;</span>, increase);
  decreaseBtn.addEventListener(<span class="hljs-string">&apos;click&apos;</span>, decrease);
};
</code></pre>
<p>It accepts a store subscriber function and two action function for increasing and decreasing the value. The first few lines of the view are just fetching the DOM elements.</p>
<p>After that we define a <code>render</code> function which puts the value inside the <code>span</code> tag. <code>updateState</code> will be called every time when the store changes. So, we pass these two functions to <code>subscribeToStore</code> because we want to get the view updated and we want to get an initial rendering. Remember how our consumers are called at least once by default.</p>
<p>The last bit is calling the action functions when we press the buttons.</p>
<h3 id="the-store">The store</h3>
<p>Every action has a type. It&apos;s a good practice to create constants for these types so we don&apos;t deal with raw strings.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> INCREASE = <span class="hljs-string">&apos;INCREASE&apos;</span>;
<span class="hljs-keyword">const</span> DECREASE = <span class="hljs-string">&apos;DECREASE&apos;</span>;
</code></pre>
<p>Very often we have only one instance of every store. For the sake of simplicity we&apos;ll create ours as a singleton.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> CounterStore = {
  _data: { value: <span class="hljs-number">0</span> },
  getValue: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._data.value;
  },
  update: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">action, change</span>) </span>{
    <span class="hljs-keyword">if</span> (action.type === INCREASE) {
      <span class="hljs-keyword">this</span>._data.value += <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (action.type === DECREASE) {
      <span class="hljs-keyword">this</span>._data.value -= <span class="hljs-number">1</span>;
    }
    change();
  }
};
</code></pre>
<p><code>_data</code> is the internal state of the store. <code>update</code> is the well known method that our dispatcher calls. We process the action inside and say <code>change()</code> when we are done. <code>getValue</code> is a public method used by the view so it reaches the needed info. In our case this is just the value of the counter.</p>
<h3 id="wiring-all-the-pieces">Wiring all the pieces</h3>
<p>So, we have the store waiting for actions from the dispatcher. We have the view defined. Let&apos;s create the store subscriber, the actions and run everything.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { createAction, createSubscriber } = Fluxiny.create();
<span class="hljs-keyword">const</span> counterStoreSubscriber = createSubscriber(CounterStore);
<span class="hljs-keyword">const</span> actions = {
  increase: createAction(INCREASE),
  decrease: createAction(DECREASE)
};

View(counterStoreSubscriber, actions.increase, actions.decrease);
</code></pre>
<p>And that&apos;s it. Our view is subscribed to the store and it renders by default because one of our consumers is actually the <code>render</code> method.</p>
<h3 id="a-live-demo">A live demo</h3>
<p>A live demo could be seen in the following JSBin <a href="http://jsbin.com/koxidu/embed?js,output" target="_blank">http://jsbin.com/koxidu/embed?js,output</a>. If that&apos;s not enough and it seems too simple for you please checkout the example in Fluxiny repository <a href="https://github.com/krasimir/fluxiny/tree/master/example" target="_blank">https://github.com/krasimir/fluxiny/tree/master/example</a>. It uses React as a view layer.</p>
<p><em>The Flux implementation discussed in this section is available here <a href="https://github.com/krasimir/fluxiny" target="_blank">github.com/krasimir/fluxiny</a>. Feel free to use it in a browser <a href="https://github.com/krasimir/fluxiny/tree/master/lib" target="_blank">directly</a> or as a <a href="https://www.npmjs.com/package/fluxiny" target="_blank">npm dependency</a>.</em></p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../chapter-07/" class="navigation navigation-prev " aria-label="Previous page: One direction data flow">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="./#flux-architecture-and-its-main-characteristics" class="navigation navigation-next " aria-label="Next page: Flux architecture and its main characteristics">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Flux","level":"3.2","depth":1,"next":{"title":"Flux architecture and its main characteristics","level":"3.2.1","depth":2,"anchor":"#flux-architecture-and-its-main-characteristics","path":"chapter-08/README.md","ref":"chapter-08/README.md#flux-architecture-and-its-main-characteristics","articles":[]},"previous":{"title":"One direction data flow","level":"3.1","depth":1,"path":"chapter-07/README.md","ref":"chapter-07/README.md","articles":[]},"dir":"ltr"},"config":{"plugins":[],"root":"./book","styles":{"website":"./styles/website.css","ebook":"./styles/ebook.css","pdf":"./styles/ebook.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Krasimir Tsonev","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a5","chapterMark":"pagebreak","pageBreaksBefore":"//*[@class='new-page']","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"React in patterns","gitbook":"3.2.3","description":"A book about common design patterns used while developing with React."},"file":{"path":"chapter-08/README.md","mtime":"2018-10-17T19:02:30.000Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-10-17T19:02:47.735Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>


# -*- coding: utf-8 -*-
"""CS46HT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/117m4zL50nNyzMQICY3IjNRiRlpT6GgA9

# Hash Tables

tables in different languages
- dictionary (Python)
- objects (JavaScript)
- HashMaps (Java)

parts of a hash table
- Hashing Function
- Data Structure to hold each Bucket
- Key Value pairs


- Hashing Function
"""

# key : value pair store known as HashTable, HashMap, Dictionary, ObjectLiteral


def my_hash(key):
  sum = 0
  for c in key:
    sum += ord(c)

  return sum


def my_hash2(key):
  sum = 0
  string_bytes = key.encode()
  for b in string_bytes:
    sum += b

  return sum

# print(my_hash("ABC"))
# print(my_hash2("ABC"))

# djb2
# encode key

# set a starting value for our hash to the prime number 5381
# take my hash value number and shift it to left by 5 or multiply it by 32
# now we take the new hash value and add the old hash value to it
# add the single byte from the char of the key
# mask the end number to fit inside 32 bit space
# return the hash


def djb2(key):
  str_key = str(key).encode()

  hash_value = 5381

  for b in str_key:
    # shifted_value = hash_value << 5
    # add_shift = shifted_value + hash_value
    # total_hash = add_shift + b
    # total_hash &= 0xffffffff # 0b11111111111111111111111111111111 32bits
    # final_hash = total_hash & 0xffffffff
    hash_value = ((hash_value << 5) + hash_value) + b
    hash_value &= 0xffffffff

  return hash_value


"""
00101000
10 << 5
10 * 32
10
20
40
80
160
320

10 * 2
mov eax, 10
shl eax, 10
mul eax, 2
mul eax, 2
mul eax, 2
mul eax, 2
mul eax, 2
mul eax, 2
mul eax, 2
mul eax, 2
mul eax, 2

10 << 2
10 * 2 -> 20 * 2

     True, False, False, True, True, True, False
and  False, False, False, True, True, True, True
     False, False, False, True, True, True, False

  111000001010101110000000010101
& 000000000000000000000011111111
  000000000000000000000000010101
"""

my_hash_number = djb2("ABCD")
print(my_hash_number)

storage = [None] * 10

"""# CODE 7506

"""


class HashTable:
# """
# A hash table with `capacity` buckets
# that accepts string keys
# """


def __init__(self, capacity):
    self.capacity = capacity  # Number of buckets in the hash table
    self.storage = [None] * capacity
    self.item_count = 0


def djb2(self, key):
    """
    DJB2 hash, 32-bit
    """
    # Cast the key to a string and get bytes
    str_key = str(key).encode()

    # Start from an arbitrary large prime
    hash_value = 5381

    # Bit-shift and sum value for each character
    for b in str_key:
        hash_value = ((hash_value << 5) + hash_value) + b
        hash_value &= 0xffffffff  # DJB2 is a 32-bit hash, only keep 32 bits

    return hash_value


def hash_index(self, key):
    """
    Take an arbitrary key and return a valid integer index
    between within the storage capacity of the hash table.
    """
    return self.djb2(key) % self.capacity


def put(self, key, value):
    """
    Store the value with the given key.
    """
    index = self.hash_index(key)
    self.storage[index] = value
    return


def delete(self, key):
    """
    Remove the value stored with the given key.
    """
    index = self.hash_index(key)
    self.storage[index] = None


def get(self, key):
# """
#     Retrieve the value stored with the given key.
#     Returns None if the key is not found.
#     """
    index = self.hash_index(key)
    return self.storage[index]


"""# CODE 7506

# Demo
"""

"""
Your task is create your own HashTable without using a built-in library.
Your HashTable needs to have the following functions:
- put(key, value) : Inserts a (key, value) pair into the HashTable. If the
value already exists in the HashTable, update the value.
- get(key): Returns the value to which the specified key is mapped, or -1 if
this map contains no mapping for the key.
- remove(key) : Remove the mapping for the value key if this map contains the
mapping for the key.
Example:
```plaintext
hash_table = MyHashTable();
hash_table.put("a", 1);
hash_table.put("b", 2);
hash_table.get("a");            // returns 1
hash_table.get("c");            // returns -1 (not found)
hash_table.put("b", 1);         // update the existing value
hash_table.get("b");            // returns 1
hash_table.remove("b");         // remove the mapping for 2
hash_table.get("b");            // returns -1 (not found)
```
"""


class ListNode:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None


"""
4000    12       89
["ABC", 10]-->["CBA", 100]-->["BAC", 2342]-->["AAAB", 400]-->None
   ^
   |
[4000, 9000, 6000] --> ["ZAB", 600]
         | 9000            99            10
         ["XYZ", 10]-->["ZYX", 134]-->["ZXY", 2342]-->None
"""


class MyHashTable:
    def __init__(self):
        # Your code here
        self.capacity = 1000
        self.size = 0
        self.storage = [None] * self.capacity

    # Your code here

    def djb2(self, key):
      """
      DJB2 hash, 32-bit
      """
      # Cast the key to a string and get bytes
      str_key = str(key).encode()

      # Start from an arbitrary large prime
      hash_value = 5381

      # Bit-shift and sum value for each character
      for b in str_key:
          hash_value = ((hash_value << 5) + hash_value) + b
          hash_value &= 0xffffffff  # DJB2 is a 32-bit hash, only keep 32 bits

      return hash_value


def hash_index(self, key):
      """
      Take an arbitrary key and return a valid integer index
      between within the storage capacity of the hash table.
      """
      return self.djb2(key) % self.capacity



    def put(self, key, value):
        # Your code here
        index = self.hash_index(key)

        if self.storage[index] == None:
          self.size += 1
          self.storage[index] = ListNode(key, value)
        else:
          current_node = self.storage[index]
          while True:
            if current_node.key == key:
              current_node.value = value
              return
            if current_node.next == None:
              break

            current_node = current_node.next

          self.size += 1
          current_node.next = ListNode(key, value)


    def get(self, key):
        index = self.hash_index(key)

        curr_node = self.storage[index]

        while curr_node:
            if curr_node.key == key:
                return curr_node.value
            else:
                curr_node = curr_node.next

        return -1

    def remove(self, key):
        index = self.hash_index(key)

        curr_node = prev_node = self.hash_table[index]

         # Removing from empty bin just return
        if not curr_node: return

        if curr_node.key == key:
            # We found the node to delete immediately, we can now skip over it
            self.hash_table[index] = curr_node.next
        else:
            # We did not find the node to delete we must now traverse the bin
            curr_node = curr_node.next

            while curr_node:
                if curr_node.key == key:
                    prev_node.next = curr_node.next
                    break
                else:
                    prev_node, curr_node = prev_node.next, curr_node.next

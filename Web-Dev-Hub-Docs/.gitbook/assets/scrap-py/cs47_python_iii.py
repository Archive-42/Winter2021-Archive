# -*- coding: utf-8 -*-
"""CS47 Python III.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Kjsasop1h7LAaLNfQ1CfbtiIkKJI76dg

# Attendance Code: 6153

# Python III
## Objectives
- perform basic dictionary operations
- recognize mutable and immutable objects
- compare the time complexity of different approaches to a problem using Big O notation
- compare the space complexity of different approaches to a problem using Big O notation
- use list comprehensions

# Dictionaries
"""

"""
Add "Herb" to the phonebook with the number 7653420789.
Remove "Bill" from the phonebook.
"""
phonebook = {"Abe": 4569874321, "Bill": 7659803241, "Barry": 6573214789}

# YOUR CODE HERE
phonebook["Herb"] = 7653420789
del phonebook["Bill"]


# Should print Herb is in the phonebook.
if "Herb" in phonebook:
    print("Herb is in the phonebook.")

# Should print Bill is not in the phonebook.
if "Bill" not in phonebook:
    print("Bill is not in the phonebook.")

"""# Mutability"""

"""
Example One
"""


my_list1 = [1, 2, 3, 4, 5, 6]
my_list2 = my_list1
# How would you verify that my_list1 and my_list2 have the same identity?
print(id(my_list1), id(my_list2))

my_list1.append(7)
# Check if my_list1 and my_list2 still have the same identity.
# If they do, why is that?
print(id(my_list1), id(my_list2))


"""
Example Two
"""
my_text1 = "Lambda School"
my_text2 = my_text1
# How would you verify that my_text1 and my_text2 have the same identity?
print("My Text", id(my_text1), id(my_text2))

my_text1 += " is awesome!"
# Check if my_text1 and my_text2 still have the same identity?
print("My Text", id(my_text1), id(my_text2))
# If they do not, why is that?

# Now check if my_text1 and my_text2 have the same value?
print("1:", my_text1, "2:", my_text2)
# Do they? Explain why or why not.


"""
Example Three
"""
# Initialize a list and assign to produce
produce = ["Apple", "Banana", "Carrot"]
# Initialize a tuple and include a reference to the produce list in the tuple
store = ("Bill's Grocery", produce)
print("store", id(store))
# Add a new item to the produce list
produce.append("Dragonfruit")
print("store", id(store))

print(dir(store))

# Did you notice that the identity of store remained the same?
# But I thought if you changed a mutable object, a new object would
# be created in memory? Why did that not occur here?

"""# Time Complexity
- Remember this for interviews
- This is not the be all and end all measure for performance
- Use this as a planning tool
- also use this when in your reflection phase of UPER
"""

"""
Constant Time O(1)
"""


def print_one_item(items):
    print(items[0])


"""
Linear Time O(n)
"""


def print_every_item(items):
    for item in items:
        print(item)


"""
Quadratic Time O(n^2)
"""


def print_pairs(items):
    for item_one in items:
        for item_two in items:
            print(item_one, item_two)


"""
What about constants?
"""


def do_a_bunch_of_stuff(items):  # O(1 + n/2 + 2000) -> O(n)
    last_idx = len(items) - 1
    print(items[last_idx])  # O(1)

    middle_idx = len(items) / 2
    idx = 0
    while idx < middle_idx:  # O(n/2)
        print(items[idx])
        idx = idx + 1

    for num in range(2000):  # O(2000)
        print(num)


"""
Most significant term
"""


def do_different_things(items):  # O(n + n^2) -> O(n^2)
    for item in items:  # O(n)
        print(item)

    for item_one in items:  # O(n * n) = O(n^2)
        for item_two in items:
            print(item_one, item_two)


"""
Big O is the worst case
"""


def search_for_thing(items, thing):  # O(n)
    for item in items:
        if item == thing:
            return True

    return False


"""
Classify the runtime complexity of the number_of_steps function below using Big O notation.
"""


def number_of_steps(num):  # O(log(n))
    steps = 0
    while num > 0:
        if num % 2 == 0:
            num = num // 2
        else:
            num = num - 1
        steps = steps + 1
    return steps


# print(number_of_steps(10))
print(number_of_steps(10000))

"""# Space Complexity"""

"""
Constant Space O(1)
"""


def print_lambda_n_times(n):
    for i in range(n):
        print("lambda")


def get_the_max(items_list):
    maximum = float("-inf")
    for item in items_list:
        if item > maximum:
            maximum = item

    return maximum


"""
Linear Space O(n)
"""


def append_to_list_n_times(n):
    my_list = []  # O(1)

    for _ in range(n):  # O(n)
        my_list.append("lambda")  # O(1)

    return my_list


"""
Use Big O notation to classify the space complexity of the function below.
"""


def fibonacci(n):  # O(n)
    lst = [0, 1]  # O(2)
    for i in range(2, n):  # O(n)
        lst.append(lst[i - 2] + lst[i - 1])  # O(2)

    return lst[n - 1]  # O(1)


"""
Use Big O notation to classify the space complexity of the function below.
"""


def fibonacci_two(n):  # O(1)
    x, y, z = 0, 1, None  # O(3)

    if n == 0:
        return x
    if n == 1:
        return y

    for i in range(2, n):
        z = x + y
        x, y = y, z

    return z


"""
Use Big O notation to classify the space complexity of the function below.
"""


def do_something(n):  # O(n^2)
    lst = []  # O(1)
    for i in range(n):  # O(n)
        for j in range(n):  # O(n)
            lst.append(i + j)  # O(n^2 * 2)

    return lst


"""# List Comprehensions"""

l = [1, 2, 3, 4, 5]
for i in range(len(l)):
    l[i] = l[i] * 2

l2 = [l[i] * 2 for i in range(len(l)) if l[i] == 4]
# for i in range(len(l)):
# l2.append(l[i] * 2)


l3 = []
for i in range(len(l)):
    l3.append(l[i] * 2)
print(l)
print(l2)
print(l3)
print(l)

"""# DEMO"""

"""
Demonstration
Given a non-empty array of integers `nums`, 
every element appears twice except except for one. 
Write a function that finds the element that only appears once.
Examples:
- create a list
- sort the list in place
- create a for loop to go through it
- check if the index at i is not eq to the index of i - 1
 - keep the item
- otherwise
  - remove the item from the list


- create a singles list

- iterate over all numbers
  - if the number is not in our singles list
    - append it to our singles list
  - otherwise
    - remove it from the singles list

- create a dictionary
- fill the dictionary with each number as a key, and a value of zero
- iterate over the numbers extracting num
  - increment the dictionary at key of num 

- return the last item in the singles list
- single_number([3,3,2]) -> 2
- single_number([5,2,3,2,3]) -> 5
- single_number([10]) -> 10
"""


def single_number(nums):
    singles = []

    for num in nums:
        if num not in singles:
            singles.append(num)
        else:
            singles.remove(num)

    return singles.pop()


print(single_number([3, 3, 2]))  #  -> 2
print(single_number([5, 2, 3, 2, 3]))  # -> 5
print(single_number([10]))  # -> 10
